PT1 
1) Cálculo do índice para k = 6 
h(k) = 2k + 3 = 2×6 + 3 = 15 
Índice = h(k) mod m = 15 mod 15 = 0 
Resposta: A chave k = 6 será inserida no índice 0. 
2) Colisões e Princípio da Casa dos Pombos 
Colisão ocorre quando duas chaves diferentes são mapeadas para o mesmo índice na 
tabela hash. 
O Princípio da Casa dos Pombos torna colisões inevitáveis porque: 
Se temos mais chaves (pombos) que índices disponíveis (casas), pelo menos um 
índice conterá múltiplas chaves 
Mesmo com menos chaves que índices, a aleatoriedade das chaves ainda pode causar 
colisões 
Na prática, o número potencial de chaves é infinito, enquanto o tamanho da tabela é 
finito 
PT2 
1) Tabela hash com m = 10 e encadeamento separado 
Chaves: {12, 42, 33, 5, 25, 35} 
Função: h(k) = k mod 10 
Índice 0:  
Índice 1:  
Índice 2: 12 → 42 
Índice 3: 33 
Índice 4:  
Índice 5: 5 → 25 → 35 
Índice 6:  
Índice 7:  
Índice 8:  
Índice 9: 
Explicação: 
h(12) = 12 mod 10 = 2 
h(42) = 42 mod 10 = 2 (colisão com 12) 
h(33) = 33 mod 10 = 3 
h(5) = 5 mod 10 = 5 
h(25) = 25 mod 10 = 5 (colisão com 5) 
h(35) = 35 mod 10 = 5 (colisão com 5 e 25) 
Por que m = 16 é ruim para chaves pares 
Explicação matemática: 
Se m = 16 = 2⁴ (potência de 2) 
Para qualquer chave par k = 2a, temos: k mod 16 = (2a) mod 16 
O resultado será sempre um número par (0, 2, 4, ..., 14) 
Consequência: Todos os índices ímpares (1, 3, 5, ..., 15) ficarão vazios 
Distribuição: Apenas 8 dos 16 índices serão utilizados, dobrando as colisões 
PT3 
Função hash para CEPs com m = 19 
def hash_cep(cep, m=19): # Converte CEP string para número cep_num = 
int(cep.replace('-', '')) 
# Usa parte variável do CEP (últimos dígitos)  
# e aplica função hash com número primo 
return (cep_num % 10000 * 31 + cep_num // 10000) % m 
Justificativa: 
Evita colisões regionais: CEPs da mesma região geralmente compartilham os primeiros 
dígitos. Ao usar os últimos dígitos primeiro, distribuímos melhor 
Multiplicação por primo (31): Ajuda a espalhar valores sequenciais 
m = 19 (primo): Minimiza padrões de colisão para dados com regularidade 
PT4 
HashMap Java (pré-versão 8) com potências de 2 
Justificativa original: 
Eficiência computacional: Para m = 2ⁿ, a operação hash mod m pode ser otimizada 
para hash & (m-1), que é muito mais rápida 
Simplicidade: Cálculo direto com operadores bitwise 
Técnica de mitigação: 
// Função hash secundária para espalhamento 
static int hash(int h) { 
h ^= (h >>> 20) ^ (h >>> 12); 
return h ^ (h >>> 7) ^ (h >>> 4); 
} 
Como funcionava: 
Hash espalhamento: Aplicava transformações bitwise complexas no hashCode original 
Máscara bitwise: index = hash(key) & (capacity-1) 
Objetivo: Quebrar padrões sequenciais nas chaves antes da redução modular 
Problema: Mesmo com essa técnica, para certos padrões de chaves (como sequências 
regulares), ainda ocorriam colisões excessivas, levando à degradação para O(n) em 
casos patológicos. 
Solução pós Java 8: Implementação híbrida - usa árvores para buckets grandes, 
mantém potências de 2 por performance, mas com hash melhorado.